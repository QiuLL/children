<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å®¶åº­è‹±è¯­å­¦ä¹ æ¸¸æˆ</title>
    <style>
        body {
            font-family: 'Baloo 2', -apple-system, "Segoe UI", Roboto, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f0f8ff;
            color: #333;
        }
        h1 {
            color: #ff6b6b;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        .section {
            background-color: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        h2 {
            color: #4d96ff;
            border-bottom: 2px dashed #4d96ff;
            padding-bottom: 10px;
        }
        .poem {
            font-family: 'Gochi Hand', cursive; /* å¯çˆ±çš„æ‰‹å†™é£æ ¼ */
            font-size: 2rem;
            line-height: 1.6;
            text-align: center;
            margin: 20px 0;
        }
        .highlight {
            background-color: #ffeb3b;
            padding: 2px 5px;
            border-radius: 3px;
            transition: background-color 0.3s;
        }
        button {
            background-color: #4d96ff;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
            transition: all 0.3s;
        }
        button:hover {
            background-color: #3a7bd5;
            transform: scale(1.05);
        }
        .speaker {
            display: inline-block;
            width: 20px;
            height: 20px;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%234d96ff"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>');
            background-size: contain;
            cursor: pointer;
            margin-left: 5px;
            vertical-align: middle;
        }
        .matching-game {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
        }
        .word-column, .meaning-column {
            width: 48%;
        }
        .word-item, .meaning-item {
            padding: 10px;
            margin: 5px 0;
            border: 1px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .word-item:hover, .meaning-item:hover {
            background-color: #f0f0f0;
        }
        .selected {
            background-color: #d4edff;
        }
        .correct {
            background-color: #c8e6c9;
        }
        .incorrect {
            background-color: #ffcdd2;
        }
        .fill-blank {
            margin: 20px 0;
        }
        .blank {
            display: inline-block;
            width: 100px;
            height: 30px;
            border-bottom: 2px solid #4d96ff;
            margin: 0 5px;
            vertical-align: middle;
            text-align: center;
            cursor: pointer;
        }
        .word-option {
            display: inline-block;
            padding: 5px 10px;
            margin: 5px;
            border: 1px solid #4d96ff;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .word-option:hover {
            background-color: #e3f2fd;
        }
        .options-container {
            margin-top: 15px;
        }
        .feedback {
            margin-top: 10px;
            font-weight: bold;
            min-height: 24px;
        }
        .positive {
            color: #2e7d32;
        }
        .negative {
            color: #c62828;
        }
        .controls {
            margin-top: 15px;
        }
        #readStatus {
            margin-top: 10px;
            font-style: italic;
            color: #666;
        }
    </style>
</head>
<body>
    <h1>ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ å®¶åº­è‹±è¯­å­¦ä¹ æ¸¸æˆ ğŸ‘µğŸ‘´</h1>
    
    <div class="section">
        <h2>çŸ­æ–‡å†…å®¹</h2>
        <div class="poem" id="poem">
            Dad, mum, brother, sister.<br>
            Grandpa, grandma, all together.<br>
            Love, love, we love each other.
        </div>
    </div>
    
    <div class="section">
        <h2>1. çŸ­æ–‡è·Ÿè¯»æ¸¸æˆ</h2>
        <p>ç‚¹å‡»"æœ—è¯»çŸ­æ–‡"æŒ‰é’®å¬çŸ­æ–‡æœ—è¯»ï¼Œç„¶åç‚¹å‡»"å¼€å§‹è·Ÿè¯»"æŒ‰é’®è¿›è¡Œè·Ÿè¯»ç»ƒä¹ ã€‚</p>
        <div class="controls">
            <button id="readPoem">æœ—è¯»çŸ­æ–‡</button>
            <button id="startRead">å¼€å§‹è·Ÿè¯»</button>
            <button id="stopRead" disabled>åœæ­¢è·Ÿè¯»</button>
        </div>
        <div id="readStatus"></div>
        <div class="feedback" id="readFeedback"></div>
    </div>
    
    <div class="section">
        <h2>2. å•è¯ä¸ä¸­æ–‡æ„æ€é…å¯¹</h2>
        <p>ç‚¹å‡»å·¦è¾¹çš„è‹±è¯­å•è¯å’Œå³è¾¹çš„ä¸­æ–‡æ„æ€è¿›è¡Œé…å¯¹ï¼Œé…å¯¹çš„å•è¯å’Œæ„æ€ä¼šé«˜äº®æ˜¾ç¤ºã€‚</p>
        <div class="matching-game">
            <div class="word-column" id="wordColumn"></div>
            <div class="meaning-column" id="meaningColumn"></div>
        </div>
        <button id="checkMatching">æ£€æŸ¥é…å¯¹</button>
        <button id="resetMatching">é‡æ–°å¼€å§‹</button>
        <div class="feedback" id="matchingFeedback"></div>
    </div>
    
    <div class="section">
        <h2>3. å•è¯å¡«ç©ºæ¸¸æˆ</h2>
        <p>ä»ä¸‹é¢çš„é€‰é¡¹ä¸­é€‰æ‹©æ­£ç¡®çš„å•è¯å¡«å…¥çŸ­æ–‡çš„ç©ºç™½å¤„ã€‚</p>
        <div class="fill-blank" id="fillBlankPoem"></div>
        <div class="options-container" id="wordOptions"></div>
        <button id="checkFillBlank">æ£€æŸ¥å¡«ç©º</button>
        <button id="resetFillBlank">é‡æ–°å¼€å§‹</button>
        <div class="feedback" id="fillBlankFeedback"></div>
    </div>

    <script>
        // çŸ­æ–‡å†…å®¹
        const poemText = "Dad, mum, brother, sister. Grandpa, grandma, all together. Love, love, we love each other.";
        const poemLines = poemText.split('. ').map(line => line + (line.endsWith('.') ? '' : '.'));
        
        // å•è¯å’Œä¸­æ–‡æ„æ€
        const vocabulary = [
            { word: "Dad", meaning: "çˆ¸çˆ¸" },
            { word: "mum", meaning: "å¦ˆå¦ˆ" },
            { word: "brother", meaning: "å…„å¼Ÿ" },
            { word: "sister", meaning: "å§å¦¹" },
            { word: "Grandpa", meaning: "çˆ·çˆ·" },
            { word: "grandma", meaning: "å¥¶å¥¶" },
            { word: "all together", meaning: "åœ¨ä¸€èµ·" },
            { word: "Love", meaning: "çˆ±" },
            { word: "each other", meaning: "å½¼æ­¤" }
        ];
        
        // 1. çŸ­æ–‡è·Ÿè¯»åŠŸèƒ½
        const poemElement = document.getElementById('poem');
        const readPoemBtn = document.getElementById('readPoem');
        const startReadBtn = document.getElementById('startRead');
        const stopReadBtn = document.getElementById('stopRead');
        const readStatus = document.getElementById('readStatus');
        const readFeedback = document.getElementById('readFeedback');
        
        let words = [];
        let currentWordIndex = 0;
        let isFollowing = false;
        let speechRecognition;
        let currentUtterance = null;

        // æœ—è¯»æ•´ç¯‡çŸ­æ–‡
        function readWholePoem() {
            if (currentUtterance) {
                speechSynthesis.cancel();
            }
            
            const utterance = new SpeechSynthesisUtterance(poemText);
            utterance.lang = 'en-US';
            currentUtterance = utterance;
            speechSynthesis.speak(utterance);
            readStatus.textContent = "æ­£åœ¨æœ—è¯»çŸ­æ–‡...";
            
            utterance.onend = function() {
                readStatus.textContent = "çŸ­æ–‡æœ—è¯»å®Œæˆ";
                currentUtterance = null;
            };
        }
        
        // åˆå§‹åŒ–è¯­éŸ³è¯†åˆ«
        function initSpeechRecognition() {
            window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!window.SpeechRecognition) {
                readFeedback.textContent = "æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«åŠŸèƒ½ï¼Œè¯·ä½¿ç”¨Chromeæˆ–Edgeæµè§ˆå™¨ã€‚";
                return false;
            }
            
            speechRecognition = new window.SpeechRecognition();
            speechRecognition.interimResults = false;
            speechRecognition.lang = 'en-US';
            speechRecognition.continuous = false;
            
            return true;
        }
        
        // é«˜äº®å½“å‰å•è¯å¹¶æœ—è¯»
        function highlightCurrentWord() {
            // ç§»é™¤ä¹‹å‰çš„é«˜äº®
            const highlighted = document.querySelectorAll('.highlight');
            highlighted.forEach(el => el.classList.remove('highlight'));
            
            if (currentWordIndex >= words.length) {
                stopFollowing();
                readStatus.textContent = "è·Ÿè¯»å®Œæˆï¼";
                return;
            }

            // é«˜äº®å½“å‰å•è¯
            const wordSpan = document.getElementById(`word-${currentWordIndex}`);
            if (wordSpan) {
                wordSpan.classList.add('highlight');
                wordSpan.scrollIntoView({ behavior: 'smooth', block: 'center' });
                
                // æœ—è¯»å•è¯
                const wordToRead = words[currentWordIndex].replace(/[.,]/g, '');
                readStatus.textContent = `è¯·è·Ÿè¯»: ${wordToRead}`;
                readFeedback.textContent = "æ­£åœ¨è†å¬æ‚¨çš„å‘éŸ³...";
                
                if (currentUtterance) {
                    speechSynthesis.cancel();
                }
                
                const utterance = new SpeechSynthesisUtterance(wordToRead);
                utterance.lang = 'en-US';
                currentUtterance = utterance;
                speechSynthesis.speak(utterance);
                
                utterance.onend = function() {
                    currentUtterance = null;
                    // å¼€å§‹è¯­éŸ³è¯†åˆ«
                    try {
                        speechRecognition.start();
                    } catch (e) {
                        console.error("è¯­éŸ³è¯†åˆ«é”™è¯¯:", e);
                        setTimeout(() => {
                            currentWordIndex++;
                            highlightCurrentWord();
                        }, 1000);
                    }
                };
            }
        }
        
        // è®¾ç½®è¯­éŸ³è¯†åˆ«å›è°ƒ
        function setupRecognitionCallbacks() {
            speechRecognition.onresult = (event) => {
                const spokenWord = event.results[0][0].transcript.trim().toLowerCase();
                const expectedWord = words[currentWordIndex].toLowerCase().replace(/[.,]/g, '');
                
                if (spokenWord === expectedWord) {
                    readFeedback.textContent = `âœ“ å‘éŸ³æ­£ç¡®ï¼æ‚¨è¯´çš„æ˜¯: "${spokenWord}"`;
                    readFeedback.className = "feedback positive";
                } else {
                    readFeedback.textContent = `å‘éŸ³ä¸å¤ªå¯¹å“¦ã€‚æ‚¨è¯´çš„æ˜¯"${spokenWord}"ï¼Œåº”è¯¥æ˜¯"${expectedWord}"ã€‚`;
                    readFeedback.className = "feedback negative";
                }
                
                // ç»§ç»­ä¸‹ä¸€ä¸ªå•è¯
                currentWordIndex++;
                setTimeout(highlightCurrentWord, 1000);
            };
            
            speechRecognition.onerror = (event) => {
                if (event.error === 'no-speech') {
                    readFeedback.textContent = "æ²¡æœ‰æ£€æµ‹åˆ°è¯­éŸ³ï¼Œè¯·å†è¯•ä¸€æ¬¡ã€‚";
                } else {
                    readFeedback.textContent = "è¯†åˆ«å‡ºé”™ï¼Œè¯·å†è¯•ä¸€æ¬¡ã€‚";
                }
                readFeedback.className = "feedback negative";
                
                // ç»§ç»­å°è¯•
                if (isFollowing) {
                    setTimeout(highlightCurrentWord, 1000);
                }
            };
        }
        
        // å¼€å§‹è·Ÿè¯»
        function startFollowing() {
            if (!initSpeechRecognition()) return;
            
            // åˆ†è§£çŸ­æ–‡ä¸ºå•è¯
            poemElement.innerHTML = poemLines.map(line => {
                const lineWords = line.split(/(\s+)/).filter(w => w.trim().length > 0);
                return lineWords.map((word, i) => 
                    `<span id="word-${words.length + i}">${word}</span>`
                ).join(' ') + '<br>';
            }).join('');
            
            words = Array.from(document.querySelectorAll('#poem span')).map(span => span.textContent);
            currentWordIndex = 0;
            isFollowing = true;
            
            readPoemBtn.disabled = true;
            startReadBtn.disabled = true;
            stopReadBtn.disabled = false;
            readStatus.textContent = "å‡†å¤‡å¼€å§‹è·Ÿè¯»...";
            readFeedback.textContent = "";
            
            setupRecognitionCallbacks();
            highlightCurrentWord();
        }
        
        // åœæ­¢è·Ÿè¯»
        function stopFollowing() {
            isFollowing = false;
            if (speechRecognition) {
                speechRecognition.stop();
            }
            if (currentUtterance) {
                speechSynthesis.cancel();
                currentUtterance = null;
            }
            
            readPoemBtn.disabled = false;
            startReadBtn.disabled = false;
            stopReadBtn.disabled = true;
            readStatus.textContent = "è·Ÿè¯»å·²åœæ­¢";
        }
        
        // æŒ‰é’®äº‹ä»¶ç›‘å¬
        readPoemBtn.addEventListener('click', readWholePoem);
        startReadBtn.addEventListener('click', startFollowing);
        stopReadBtn.addEventListener('click', stopFollowing);
        
        // 2. å•è¯ä¸ä¸­æ–‡æ„æ€é…å¯¹æ¸¸æˆ
        const wordColumn = document.getElementById('wordColumn');
        const meaningColumn = document.getElementById('meaningColumn');
        const checkMatchingBtn = document.getElementById('checkMatching');
        const resetMatchingBtn = document.getElementById('resetMatching');
        const matchingFeedback = document.getElementById('matchingFeedback');
        
        let selectedWord = null;
        let selectedMeaning = null;
        let matches = [];
        
        // åˆ›å»ºå–‡å­å›¾æ ‡
        function createSpeakerIcon() {
            const speaker = document.createElement('span');
            speaker.className = 'speaker';
            speaker.onclick = function(e) {
                e.stopPropagation();
                const word = this.parentElement.textContent.replace('ğŸ”Š', '').trim();
                const utterance = new SpeechSynthesisUtterance(word);
                utterance.lang = 'en-US';
                speechSynthesis.speak(utterance);
            };
            return speaker;
        }
        
        // åˆå§‹åŒ–é…å¯¹æ¸¸æˆ
        function initMatchingGame() {
            wordColumn.innerHTML = '';
            meaningColumn.innerHTML = '';
            matches = [];
            selectedWord = null;
            selectedMeaning = null;
            matchingFeedback.textContent = '';
            
            // æ‰“ä¹±å•è¯å’Œæ„æ€çš„é¡ºåº
            const shuffledWords = [...vocabulary].sort(() => Math.random() - 0.5);
            const shuffledMeanings = [...vocabulary].map(v => v.meaning).sort(() => Math.random() - 0.5);
            
            // æ·»åŠ å•è¯
            shuffledWords.forEach((item, index) => {
                const wordItem = document.createElement('div');
                wordItem.className = 'word-item';
                wordItem.textContent = item.word;
                wordItem.appendChild(createSpeakerIcon());
                wordItem.dataset.index = index;
                wordItem.dataset.word = item.word;
                
                wordItem.addEventListener('click', () => {
                    if (wordItem.classList.contains('correct')) return;
                    
                    if (selectedWord === wordItem) {
                        wordItem.classList.remove('selected');
                        selectedWord = null;
                    } else {
                        document.querySelectorAll('.word-item').forEach(item => item.classList.remove('selected'));
                        wordItem.classList.add('selected');
                        selectedWord = wordItem;
                        
                        if (selectedMeaning) {
                            checkPair();
                        }
                    }
                });
                
                wordColumn.appendChild(wordItem);
            });
            
            // æ·»åŠ ä¸­æ–‡æ„æ€
            shuffledMeanings.forEach((meaning, index) => {
                const meaningItem = document.createElement('div');
                meaningItem.className = 'meaning-item';
                meaningItem.textContent = meaning;
                meaningItem.dataset.index = index;
                meaningItem.dataset.meaning = meaning;
                
                meaningItem.addEventListener('click', () => {
                    if (meaningItem.classList.contains('correct')) return;
                    
                    if (selectedMeaning === meaningItem) {
                        meaningItem.classList.remove('selected');
                        selectedMeaning = null;
                    } else {
                        document.querySelectorAll('.meaning-item').forEach(item => item.classList.remove('selected'));
                        meaningItem.classList.add('selected');
                        selectedMeaning = meaningItem;
                        
                        if (selectedWord) {
                            checkPair();
                        }
                    }
                });
                
                meaningColumn.appendChild(meaningItem);
            });
        }
        
        // æ£€æŸ¥é…å¯¹
        function checkPair() {
            const word = selectedWord.dataset.word;
            const meaning = selectedMeaning.dataset.meaning;
            
            const isCorrect = vocabulary.some(v => v.word === word && v.meaning === meaning);
            
            if (isCorrect) {
                selectedWord.classList.add('correct');
                selectedMeaning.classList.add('correct');
                selectedWord.classList.remove('selected');
                selectedMeaning.classList.remove('selected');
                selectedWord.style.pointerEvents = 'none';
                selectedMeaning.style.pointerEvents = 'none';
                
                matches.push({
                    word: selectedWord,
                    meaning: selectedMeaning
                });
                
                selectedWord = null;
                selectedMeaning = null;
                
                if (matches.length === vocabulary.length) {
                    matchingFeedback.textContent = "âœ“ å…¨éƒ¨é…å¯¹æ­£ç¡®ï¼å¤ªæ£’äº†ï¼";
                    matchingFeedback.className = "feedback positive";
                }
            } else {
                selectedWord.classList.add('incorrect');
                selectedMeaning.classList.add('incorrect');
                
                setTimeout(() => {
                    selectedWord.classList.remove('incorrect');
                    selectedMeaning.classList.remove('incorrect');
                    selectedWord.classList.remove('selected');
                    selectedMeaning.classList.remove('selected');
                    selectedWord = null;
                    selectedMeaning = null;
                }, 1000);
            }
        }
        
        // æ£€æŸ¥æ‰€æœ‰é…å¯¹
        checkMatchingBtn.addEventListener('click', () => {
            const allCorrect = matches.length === vocabulary.length;
            
            if (allCorrect) {
                matchingFeedback.textContent = "âœ“ å…¨éƒ¨é…å¯¹æ­£ç¡®ï¼å¤ªæ£’äº†ï¼";
                matchingFeedback.className = "feedback positive";
            } else {
                matchingFeedback.textContent = `è¿˜æœ‰${vocabulary.length - matches.length}ä¸ªå•è¯æ²¡æœ‰é…å¯¹æ­£ç¡®ï¼Œç»§ç»­åŠ æ²¹ï¼`;
                matchingFeedback.className = "feedback negative";
            }
        });
        
        // é‡ç½®é…å¯¹æ¸¸æˆ
        resetMatchingBtn.addEventListener('click', initMatchingGame);
        
        // 3. å•è¯å¡«ç©ºæ¸¸æˆ
        const fillBlankPoem = document.getElementById('fillBlankPoem');
        const wordOptions = document.getElementById('wordOptions');
        const checkFillBlankBtn = document.getElementById('checkFillBlank');
        const resetFillBlankBtn = document.getElementById('resetFillBlank');
        const fillBlankFeedback = document.getElementById('fillBlankFeedback');
        
        let blankElements = [];
        let selectedOption = null;
        let selectedBlank = null;
        let wordOptionsElements = [];
        
        // åˆå§‹åŒ–å¡«ç©ºæ¸¸æˆ
        function initFillBlankGame() {
            fillBlankPoem.innerHTML = '';
            wordOptions.innerHTML = '';
            blankElements = [];
            wordOptionsElements = [];
            selectedOption = null;
            selectedBlank = null;
            fillBlankFeedback.textContent = '';
            
            // åˆ›å»ºå¡«ç©ºçŸ­æ–‡
            const wordsToBlank = ['Dad', 'mum', 'brother', 'sister', 'Grandpa', 'grandma', 'Love', 'love'];
            let blankIndex = 0;
            
            poemLines.forEach((line, lineIndex) => {
                const lineWords = line.split(/(\s+)/).filter(w => w.trim().length > 0);
                const lineElement = document.createElement('div');
                
                lineWords.forEach((word, wordIndex) => {
                    const cleanWord = word.replace(/[.,]/g, '');
                    
                    if (wordsToBlank.includes(cleanWord)) {
                        const blank = document.createElement('span');
                        blank.className = 'blank';
                        blank.dataset.correct = cleanWord;
                        blank.dataset.index = blankIndex++;
                        blank.textContent = '______';
                        
                        blank.addEventListener('click', function() {
                            // å–æ¶ˆä¹‹å‰çš„é€‰æ‹©
                            document.querySelectorAll('.blank').forEach(b => {
                                b.style.borderBottom = '2px solid #4d96ff';
                            });
                            
                            // é€‰æ‹©å½“å‰ç©ºç™½
                            this.style.borderBottom = '2px solid #ff6b6b';
                            selectedBlank = this;
                            
                            // å¦‚æœæœ‰é€‰ä¸­çš„å•è¯é€‰é¡¹ï¼Œç›´æ¥å¡«å……
                            if (selectedOption) {
                                fillBlank();
                            }
                        });
                        
                        lineElement.appendChild(blank);
                        blankElements.push(blank);
                        
                        // æ·»åŠ æ ‡ç‚¹ç¬¦å·
                        if (word.endsWith('.') || word.endsWith(',')) {
                            lineElement.appendChild(document.createTextNode(word.slice(-1)));
                        }
                    } else {
                        lineElement.appendChild(document.createTextNode(word));
                    }
                    
                    // æ·»åŠ ç©ºæ ¼
                    if (wordIndex < lineWords.length - 1) {
                        lineElement.appendChild(document.createTextNode(' '));
                    }
                });
                
                fillBlankPoem.appendChild(lineElement);
            });
            
            // å‡†å¤‡å•è¯é€‰é¡¹
            const uniqueWords = [...new Set(wordsToBlank)];
            
            uniqueWords.forEach((word, index) => {
                const option = document.createElement('div');
                option.className = 'word-option';
                option.textContent = word;
                option.dataset.word = word;
                option.appendChild(createSpeakerIcon());
                
                option.addEventListener('click', function() {
                    // å–æ¶ˆä¹‹å‰çš„é€‰æ‹©
                    wordOptionsElements.forEach(opt => {
                        opt.style.backgroundColor = '';
                    });
                    
                    // é€‰æ‹©å½“å‰é€‰é¡¹
                    this.style.backgroundColor = '#e3f2fd';
                    selectedOption = this.dataset.word;
                    
                    // å¦‚æœæœ‰é€‰ä¸­çš„ç©ºç™½ï¼Œç›´æ¥å¡«å……
                    if (selectedBlank) {
                        fillBlank();
                    }
                });
                
                wordOptions.appendChild(option);
                wordOptionsElements.push(option);
            });
        }
        
        // å¡«ç©º
        function fillBlank() {
            if (!selectedBlank || !selectedOption) return;
            
            selectedBlank.textContent = selectedOption;
            selectedBlank.dataset.filled = selectedOption;
            selectedBlank.style.borderBottom = '2px solid #4d96ff';
            
            // é‡ç½®é€‰æ‹©
            wordOptionsElements.forEach(opt => {
                opt.style.backgroundColor = '';
            });
            selectedBlank = null;
            selectedOption = null;
        }
        
        // æ£€æŸ¥å¡«ç©º
        checkFillBlankBtn.addEventListener('click', () => {
            let allCorrect = true;
            let filledCount = 0;
            
            blankElements.forEach(blank => {
                if (blank.dataset.filled) {
                    filledCount++;
                    
                    if (blank.dataset.filled === blank.dataset.correct) {
                        blank.style.backgroundColor = '#c8e6c9';
                    } else {
                        blank.style.backgroundColor = '#ffcdd2';
                        allCorrect = false;
                    }
                } else {
                    allCorrect = false;
                }
            });
            
            if (filledCount === 0) {
                fillBlankFeedback.textContent = "è¯·å…ˆé€‰æ‹©å•è¯å¡«å…¥ç©ºç™½å¤„ã€‚";
                fillBlankFeedback.className = "feedback negative";
            } else if (allCorrect && filledCount === blankElements.length) {
                fillBlankFeedback.textContent = "âœ“ å…¨éƒ¨å¡«ç©ºæ­£ç¡®ï¼å¤ªæ£’äº†ï¼";
                fillBlankFeedback.className = "feedback positive";
            } else {
                fillBlankFeedback.textContent = `è¿˜æœ‰${blankElements.length - filledCount}ä¸ªç©ºç™½æœªå¡«ï¼Œå·²å¡«çš„${filledCount}ä¸ªä¸­æœ‰${blankElements.filter(b => b.dataset.filled && b.dataset.filled !== b.dataset.correct).length}ä¸ªä¸æ­£ç¡®ã€‚`;
                fillBlankFeedback.className = "feedback negative";
            }
        });
        
        // é‡ç½®å¡«ç©ºæ¸¸æˆ
        resetFillBlankBtn.addEventListener('click', initFillBlankGame);
        
        // åˆå§‹åŒ–æ‰€æœ‰æ¸¸æˆ
        window.onload = function() {
            initMatchingGame();
            initFillBlankGame();
        };
    </script>
</body>
</html>
